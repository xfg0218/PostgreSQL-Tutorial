**摘要**: 在本教程中，你将学习如何使用 `PostgreSQL` 的 `UNIQUE` 约束来确保特定列或列组合中的所有值在整个表中都是唯一的。

# `PostgreSQL UNIQUE` 约束简介

在 `PostgreSQL` 中，你可以使用 `UNIQUE` 约束来确保一列或多列组合中的所有值在整个表中都是唯一的。

以下是定义 `UNIQUE` 约束的语法:

```sql
CREATE TABLE table_name (
  column1 data_type CONSTRAINT constraint_name UNIQUE,
  ...
);
```

在该语法中:

首先，为 `UNIQUE` 约束指定约束名称。当你向表中插入或更新一个值为表中已存在的新值时，`PostgreSQL` 会发出包含该约束名称的错误。这个约束名称有助于你更快地发现问题所在。

请注意，`CONSTRAINT constraint_name` 是可选的。如果省略它，`PostgreSQL` 会按照以下格式自动生成一个约束名称：

```sql
{table_name}_{column_name}_key
```

其次，使用 `UNIQUE` 关键字告知 `PostgreSQL` ，你将要为该列创建一个 `UNIQUE` 约束。

这种语法会创建一个列约束，因为我们将其定义为列定义的一部分。

你可以将 `UNIQUE` 约束定义为表约束:

```sql
CREATE TABLE table_name (
  column1 data_type,
  ...,
  CONSTRAINT constraint_name UNIQUE
);
```

在这种语法中，我们在列列表之后定义 `UNIQUE` 约束。

实际上，当包含两个或多个列时，你通常会定义一个 `UNIQUE` 表约束:

```sql
CREATE TABLE table_name (
  column1 data_type,
  column2 data_type,
  CONSTRAINT constraint_name UNIQUE (column1, column2)
);
```

# 定义包含一个列的 `UNIQUE` 约束

首先，创建一个名为 `brands` 的表来存储 brands:

```sql
CREATE TABLE brands (
  brand_id INT GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
  name VARCHAR(255) NOT NULL UNIQUE
);
```

这个 `brands` 表中的 `name` 名称列具有唯一约束。这意味着 `name` 名称列中不会有重复值。

如果您插入的品牌已存在于 `brands` 表中，`PostgreSQL` 会通过抛出错误来处理，以确保数据完整性。

其次，向 `brands` 表中插入一个新行:

```sql
INSERT INTO
  brands (name)
VALUES
  ('Apple') 
RETURNING *;
```

输出:

```sql
 brand_id | name
----------+-------
        1 | Apple
```

第三,尝试再次将 `Apple` 品牌插入到 `brands` 表中:

```sql
INSERT INTO
  brands (name)
VALUES
  ('Apple') 
RETURNING *;
```

`PostgreSQL` 发出了以下错误:

```sql
ERROR: duplicate key value violates unique constraint "brands_name_key"
```

该错误意味着你正尝试在 `brands` 表的 `name` 列中插入一个已存在的值，这违反了唯一约束 ` brands_name_key` 。

# 定义包含多列的 `UNIQUE` 约束

首先,创建一个表 `product_loans` 来存储产品 `product` 表:

```sql
CREATE TABLE product_loans (
  loan_id INT GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
  product_id INT NOT NULL,
  user_id INT NOT NULL,
  loan_date DATE NOT NULL,
  return_date DATE,
  UNIQUE (product_id, user_id)
);
```

此示例定义了一个包含 `UNIQUE` 约束的 `product_id` 和 `user_id` 列。

其次，向 `product_loans` 表中插入行:

```sql
INSERT INTO
  product_loans (product_id, user_id, loan_date)
VALUES
  (1, 1, '2024-11-23'),
  (1, 2, '2024-11-23') 
RETURNING *;
```

输出:

```sql
 loan_id | product_id | user_id | loan_date  | return_date
---------+------------+---------+------------+-------------
       1 |          1 |       1 | 2024-11-23 | NULL
       2 |          1 |       2 | 2024-11-23 | NULL
```

第三,尝试插入一行新数据，其中 `product_id` 和 `user_id` 列的值均为重复值:

```sql
INSERT INTO
  product_loans (product_id, user_id, loan_date)
VALUES
  (1, 1, '2024-11-24');
```

错误:

```sql
duplicate key value violates unique constraint "product_loans_product_id_user_id_key"
```

# 使用 `UNIQUE` 约束处理 `NULL`

在 `PostgreSQL` 中，`NULL` 与另一个 `NULL` 不同。因此，你可以在具有 `UNIQUE` 约束的列中插入多个 `NULL` 。例如:

首先,创建一个名为 `profiles` 的表来存储用户资料:

```sql
CREATE TABLE profiles (
  user_id INT PRIMARY KEY,
  first_name VARCHAR(50) NOT NULL,
  last_name VARCHAR(50) NOT NULL,
  phone VARCHAR(25) UNIQUE
);
```

`phone` 列可为空且具有 `UNIQUE` 约束。

其次，向 `profiles` 表中插入一行新数据:

```sql
INSERT INTO
  profiles (user_id, first_name, last_name, phone)
VALUES
  (1, 'John', 'Doe', NULL) 
RETURNING *;
```

输出:

```sql
 user_id | first_name | last_name | phone
---------+------------+-----------+-------
       1 | John       | Doe       | NULL
```

第三,尝试向 `profiles` 表中插入一行新数据，其中 `phone` 列的值为 `NULL` :

```sql
INSERT INTO
  profiles (user_id, first_name, last_name, phone)
VALUES
  (2, 'Jane', 'Doe', NULL) 
RETURNING *;
```

输出:

```sql
 user_id | first_name | last_name | phone
---------+------------+-----------+-------
       2 | Jane       | Doe       | NULL
```

最后，从 `profiles` 表中查询数据:

```sql
SELECT * FROM profiles;
```

输出:

```sql
 user_id | first_name | last_name | phone
---------+------------+-----------+-------
       1 | John       | Doe       | NULL
       2 | Jane       | Doe       | NULL
```

# 总结

- 利用 `PostgreSQL` 的 `UNIQUE` 约束确保一个或多个列中的值在同一表内是唯一的。

